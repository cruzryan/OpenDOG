<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quadruped Dashboard (DMP)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff; --card-bg-color: #f9f9f9; --border-color: #e0e0e0;
            --text-color: #333333; --text-muted-color: #777777; --accent-color: #000000;
            --icon-color: #333333; --button-text-color: #ffffff; --button-bg-color: #000000;
            --success-color: #28a745; --error-color: #dc3545; --graph-line-color: #000000;
            --graph-grid-color: #eeeeee;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 20px; background-color: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; min-height: 100vh;
            box-sizing: border-box; overflow-x: hidden;
        }
        .dashboard-header { width: 100%; max-width: 1800px; text-align: center; margin-bottom: 15px; }
        .dashboard-header h1 { color: var(--accent-color); margin-bottom: 5px; font-size: 2.2em; font-weight: 600;}
        .status-bar { font-size: 0.9em; color: var(--text-muted-color); margin-bottom: 15px; display: flex; justify-content: center; align-items: center; gap: 20px;}
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; }

        .controls-panel {
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 12px;
            background-color: var(--card-bg-color); padding: 15px; border-radius: 8px;
            border: 1px solid var(--border-color); margin-bottom: 20px; width: 100%; max-width: 1200px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .control-button, .motor-control select, .motor-control input, .motor-control button {
            background-color: var(--button-bg-color); color: var(--button-text-color); border: none;
            padding: 10px 15px; border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 500;
            display: flex; align-items: center; gap: 8px; transition: background-color 0.2s ease;
        }
        .control-button:hover, .motor-control button:hover { background-color: #333333; }
        .motor-control { display: flex; gap: 8px; align-items: center; }
        .motor-control select, .motor-control input[type="number"] { background-color: #fff; color: var(--text-color); border: 1px solid var(--border-color); padding: 9px; border-radius: 6px;}
        .motor-control input[type="number"] { width: 70px; text-align: right; }

        .main-content-area {
            display: flex;
            flex-direction: column;
            gap: 20px; width: 100%; max-width: 1800px;
        }
        .info-cards-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }
        .leg-cards-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }
        .grid-card {
            background-color: #ffffff; border: 1px solid var(--border-color);
            border-radius: 8px; padding: 15px;
            display: flex; flex-direction: column;
            box-shadow: 0 3px 6px rgba(0,0,0,0.07); min-height: 200px;
        }
        .grid-card h2 { color: var(--accent-color); font-size: 1.0em; font-weight: 600; margin-top: 0; margin-bottom: 10px; text-align: left; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;}
        .grid-card h3 { font-size: 0.9em; font-weight: 500; margin-top: 10px; margin-bottom: 5px; color: var(--text-color); }

        .esp-info-card .dmp-section { display: flex; flex-direction: column; align-items: center; gap: 8px; margin-bottom:10px; }
        .dmp-canvas-container { /* Renamed from imu-canvas-container */
            width: 450px; height: 450px; border: 1px solid var(--border-color);
            background-color: #f0f0f0; margin-bottom: 5px;
            margin-left: auto; margin-right: auto;
        }
        .dmp-text-data p { margin: 2px 0; font-size: 0.85em; color: var(--text-muted-color); text-align: center; }
        .dmp-text-data p strong { color: var(--text-color); font-weight: 500;}


        .data-age-card h2, .leg-card h2 { display: flex; justify-content: space-between; align-items: center; }
        .current-value-display { font-size: 0.85em; color: var(--text-muted-color); font-weight: normal; }

        .chart-container { height: 150px; }
        .motor-leg-charts-container { display: flex; flex-direction: column; gap: 10px; flex-grow: 1; }
        .motor-chart-item { height: 120px;  }

        .command-status { font-size: 0.9em; margin-top: 8px; height: 20px; text-align: center; width: 100%; font-weight: 500;}
        .icon { font-size: 1.2em; }

        @media (min-width: 700px) {
             .leg-cards-grid-container.layout-2x2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <h1>Quadruped Dashboard</h1>
        <div class="status-bar">
            <span><span id="ws-status-dot" class="status-dot"></span> WebSocket: <span id="ws-status">Connecting...</span></span>
            <span>UI Update Interval: <span id="ui-update-interval-value" class="current-value-display">(- ms)</span></span>
            <span>Last Data: <span id="last-update-time">-</span></span>
        </div>
    </div>

    <div class="controls-panel">
        <button id="init-robot-btn" class="control-button"><span class="icon">‚öôÔ∏è</span>Initialize</button>
        <button id="toggle-control-btn" class="control-button"><span class="icon">‚ö°</span>Enable Control</button>
        <button id="reset-hw-btn" class="control-button"><span class="icon">üîÑ</span>Reset HW</button>
        <div class="motor-control">
            <select id="motor-select"></select>
            <input type="number" id="motor-angle-input" value="0" min="-180" max="180" step="1">
            <button id="send-angle-btn"><span class="icon">‚û°Ô∏è</span>Set</button>
        </div>
    </div>
    <div id="command-status-msg" class="command-status"></div>

    <div class="main-content-area" id="main-content-area">
        <div class="info-cards-row">
            <div id="esp0-column" class="grid-card esp-info-card" style="display:none;">
                <h2>ESP 1 (<span id="esp0-ip">-</span>) <span id="esp0-data-status" class="status-dot"></span></h2>
                <div id="esp0-dmp-section" class="dmp-section" style="display:none;"> <!-- Renamed class -->
                    <h3>DMP Orientation & Data</h3>
                    <div id="dmpCubeContainer-esp0" class="dmp-canvas-container"></div> <!-- Renamed ID and class -->
                    <div id="esp0-dmp-text" class="dmp-text-data"></div> <!-- Renamed ID and class -->
                </div>
                <div class="data-age-section">
                    <h3>Data Freshness <span id="esp0-data-age-value" class="current-value-display">(- ms)</span></h3>
                    <div class="chart-container"><canvas id="esp0DataAgeChart"></canvas></div>
                </div>
            </div>
            <div id="esp1-column" class="grid-card esp-info-card" style="display:none;">
                <h2>ESP 2 (<span id="esp1-ip">-</span>) <span id="esp1-data-status" class="status-dot"></span></h2>
                <div id="esp1-dmp-section" class="dmp-section" style="display:none;"> <!-- Renamed class -->
                    <h3>DMP Orientation & Data</h3>
                    <div id="dmpCubeContainer-esp1" class="dmp-canvas-container"></div> <!-- Renamed ID and class -->
                    <div id="esp1-dmp-text" class="dmp-text-data"></div> <!-- Renamed ID and class -->
                </div>
                 <div class="data-age-section">
                    <h3>Data Freshness <span id="esp1-data-age-value" class="current-value-display">(- ms)</span></h3>
                    <div class="chart-container"><canvas id="esp1DataAgeChart"></canvas></div>
                </div>
            </div>
            <div class="grid-card ui-interval-card">
                 <h2>UI Update Interval <span id="uiUpdateIntervalChartValue" class="current-value-display">(- ms)</span></h2>
                <div class="chart-container"><canvas id="uiUpdateIntervalChart"></canvas></div>
            </div>
        </div>
        <div class="leg-cards-grid-container layout-2x2" id="leg-cards-grid-container">
        </div>
    </div>

    <script>
        function getCssVariableValue(variableName) { return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim(); }

        let motorConfigListFromPython = []; let legsOrderFromPython = [];
        try { const rmcj = '{{ motor_config_list_json | safe }}'; if (rmcj && rmcj!=='None'&&rmcj.trim()!==''&&rmcj!=='null') motorConfigListFromPython=JSON.parse(rmcj); else console.warn("motor_cfg empty",rmcj); } catch (e) { console.error("Err motor_cfg",e, '{{ motor_config_list_json | safe }}'); }
        try { const rloj = '{{ legs_order_list_json | safe }}'; if (rloj && rloj!=='None'&&rloj.trim()!==''&&rloj!=='null') legsOrderFromPython=JSON.parse(rloj); else console.warn("legs_order empty",rloj); } catch (e) { console.error("Err legs_order",e, '{{ legs_order_list_json | safe }}'); }

        const numMotors = motorConfigListFromPython.length;

        const wsStatusEl = document.getElementById('ws-status'); const wsStatusDotEl = document.getElementById('ws-status-dot');
        const motorSelectEl = document.getElementById('motor-select');
        const toggleControlBtn = document.getElementById('toggle-control-btn');
        const uiUpdateIntervalValueEl = document.getElementById('uiUpdateIntervalChartValue');
        const legCardsContainer = document.getElementById('leg-cards-grid-container');


        const MAX_CHART_POINTS = 30;
        let uiUpdateIntervalChart;
        let espDataAgeCharts = {};
        let motorAngleCharts = {};
        let dmpVisualizers = {}; // Changed from imuVisualizers
        let currentMotorTargetAngles = new Array(numMotors > 0 ? numMotors : 8).fill(0.0);
        let clientSideControlEnabled = false;

        if (motorSelectEl && motorConfigListFromPython && motorConfigListFromPython.length > 0) { motorConfigListFromPython.forEach(motor => { const option = document.createElement('option'); option.value = motor.id; option.textContent = `${motor.name} (ID ${motor.id})`; motorSelectEl.appendChild(option); }); } else { console.warn("Motor select not populated."); }

        const socket = io();
        socket.on('connect', () => { wsStatusEl.textContent = 'Connected'; wsStatusDotEl.style.backgroundColor = 'var(--success-color)'; });
        socket.on('disconnect', () => { wsStatusEl.textContent = 'Disconnected'; wsStatusDotEl.style.backgroundColor = 'var(--error-color)'; });

        socket.on('initial_config', (data) => {
            if (!data || !data.motors || !data.legs_order) { console.error("Malformed initial_config:", data); return; }
            motorConfigListFromPython = data.motors; legsOrderFromPython = data.legs_order;
            clientSideControlEnabled = data.control_enabled;
            updateToggleButtonText();
            try { setupUiUpdateIntervalChart(); } catch (e) { console.error("Err UI Chart:", e); }
            createEspDataAgeChart('esp0');
            createEspDataAgeChart('esp1');
            try { setupMotorAngleCharts(motorConfigListFromPython, legsOrderFromPython); } catch (e) { console.error("Err Motor Charts:", e); }
        });

        socket.on('command_status', (data) => {
            const commandStatusMsgEl = document.getElementById('command-status-msg');
            if (commandStatusMsgEl) {
                 commandStatusMsgEl.textContent = `[${data.command}]: ${data.message}`;
                 commandStatusMsgEl.style.color = data.success ? 'var(--success-color)' : 'var(--error-color)';
                 if (data.hasOwnProperty('control_enabled')) { clientSideControlEnabled = data.control_enabled; updateToggleButtonText(); }
                setTimeout(() => { commandStatusMsgEl.textContent = ''; }, 7000);
            }
        });

        let lastDataReceiveTime = performance.now();
        socket.on('robot_data_update', (data) => {
            const now = performance.now(); const interval = now - lastDataReceiveTime; lastDataReceiveTime = now;
            if (uiUpdateIntervalChart) { updateChart(uiUpdateIntervalChart, interval); }
            if (uiUpdateIntervalValueEl) uiUpdateIntervalValueEl.textContent = `(${interval.toFixed(0)} ms)`;
            const lastUpdateEl = document.getElementById('last-update-time'); const date = new Date(data.timestamp * 1000);
            if (lastUpdateEl) lastUpdateEl.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            if (data.hasOwnProperty('control_enabled_server_state')) { clientSideControlEnabled = data.control_enabled_server_state; updateToggleButtonText(); }
            try { updateDashboardUI(data); } catch (e) { console.error("Error in updateDashboardUI:", e, "Data:", data); }
        });


        const initRobotBtn = document.getElementById('init-robot-btn'); if (initRobotBtn) initRobotBtn.addEventListener('click', () => socket.emit('request_robot_init'));
        if (toggleControlBtn) toggleControlBtn.addEventListener('click', () => socket.emit('request_toggle_control'));
        const resetHwBtn = document.getElementById('reset-hw-btn'); if (resetHwBtn) resetHwBtn.addEventListener('click', () => socket.emit('request_reset_all_hw'));
        const sendAngleBtn = document.getElementById('send-angle-btn'); const motorAngleInputEl = document.getElementById('motor-angle-input');
        if (sendAngleBtn && motorSelectEl && motorAngleInputEl) { sendAngleBtn.addEventListener('click', () => { const motorId = parseInt(motorSelectEl.value); const angle = parseFloat(motorAngleInputEl.value); if (!isNaN(motorId) && !isNaN(angle)) { if (!clientSideControlEnabled) { alert("Control is disabled."); return; } let anglesToSend = [...currentMotorTargetAngles]; anglesToSend[motorId] = angle; socket.emit('request_set_angles', { angles: anglesToSend }); } });}

        function updateToggleButtonText() { if (toggleControlBtn) { if (clientSideControlEnabled) { toggleControlBtn.innerHTML = '<span class="icon">üö´</span>Disable Control'; } else { toggleControlBtn.innerHTML = '<span class="icon">‚ö°</span>Enable Control'; } } }

        function chartOptions(custom = {}) { return { responsive: true, maintainAspectRatio: false, animation: false, scales: { y: { suggestedMin: custom.yMin, suggestedMax: custom.yMax, title: { display: !!custom.yLabel, text: custom.yLabel, color: 'var(--text-muted-color)'}, ticks: { color: 'var(--text-muted-color)', font: {size: 10} }, grid: { color: 'var(--graph-grid-color)' } }, x: { display: false, grid: { color: 'var(--graph-grid-color)' } } }, plugins: { legend: { display: false }, title: { display: true, text: custom.titleText || '', color: 'var(--text-color)', font: {size: 12, weight: '500'}, padding: { top:0, bottom:5}, align: 'start' } } }; }

        function setupUiUpdateIntervalChart() {
            const canvasEl = document.getElementById('uiUpdateIntervalChart');
            if (!canvasEl) { console.error("uiUpdateIntervalChart canvas not found!"); return; }
            const ctx = canvasEl.getContext('2d');
            uiUpdateIntervalChart = new Chart(ctx, {
                type: 'line', data: { labels: [], datasets: [{ data: [], borderColor: getCssVariableValue('--graph-line-color'), borderWidth: 1.5, pointRadius: 0, tension: 0.3, fill: false }] },
                options: chartOptions({ yMin: 0, yMax: 200, titleText: ' ' })
            });
        }

        function createEspDataAgeChart(espIdString) {
            if (espDataAgeCharts[espIdString]) return;
            const canvasEl = document.getElementById(`${espIdString}DataAgeChart`);
            if (!canvasEl) { console.warn(`Canvas for ${espIdString}DataAgeChart not found.`); return; }
            const ctx = canvasEl.getContext('2d');
            espDataAgeCharts[espIdString] = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: getCssVariableValue('--graph-line-color'), borderWidth: 1.5, pointRadius: 0, tension: 0.3, fill: false }] },
                options: chartOptions({ yMin: 0, yMax: 500, titleText: ` ` })
            });
        }

        function setupMotorAngleCharts(motors, legsOrderToUse) {
            if (!motors || !legsOrderToUse || !legCardsContainer) { console.error("Missing data for motor chart setup or leg container not found."); return; }
            legCardsContainer.innerHTML = '';
            motorAngleCharts = {};

            const legOrderMap = { "FL": 0, "FR": 1, "BL": 2, "BR": 3 };
            const sortedLegsOrder = legsOrderToUse.slice().sort((a, b) => {
                const nameA = a.toUpperCase().replace(" LEG", "");
                const nameB = b.toUpperCase().replace(" LEG", "");
                return (legOrderMap[nameA] ?? 99) - (legOrderMap[nameB] ?? 99);
            });

            if (sortedLegsOrder.length === 4 && legCardsContainer.classList.contains('layout-2x2')) {
                 console.log("Applying 2x2 layout for 4 legs.");
            } else {
                legCardsContainer.classList.remove('layout-2x2');
                console.log("Using auto-fit layout for legs.");
            }

            sortedLegsOrder.forEach(legName => {
                const legCard = document.createElement('div'); legCard.classList.add('grid-card', 'leg-card'); legCard.id = `leg-card-${legName.toLowerCase().replace(/\s+/g, '-')}`;
                legCard.innerHTML = `<h2>${legName} <span class="current-value-display">(Enc / Tgt / Angle ¬∞)</span></h2><div class="motor-leg-charts-container"></div>`; // Updated subtitle
                legCardsContainer.appendChild(legCard);
                const legChartContainer = legCard.querySelector('.motor-leg-charts-container');
                if (!legChartContainer) { console.error(`No .motor-leg-charts-container in ${legName}`); return; }
                motors.filter(m => m.leg === legName).sort((a,b) => (a.type === "Hip" ? -1 : 1)).forEach(motor => {
                    const chartItemDiv = document.createElement('div'); chartItemDiv.classList.add('motor-chart-item');
                    const canvas = document.createElement('canvas'); chartItemDiv.appendChild(canvas); legChartContainer.appendChild(chartItemDiv);
                    const ctx = canvas.getContext('2d');
                    motorAngleCharts[motor.id] = new Chart(ctx, { type: 'line',
                        data: { labels: [], datasets: [{ data: [], borderColor: getCssVariableValue('--graph-line-color'), borderWidth: 1.5, pointRadius: 0, tension: 0.3, fill: false }] },
                        options: chartOptions({ yMin: -120, yMax: 120, titleText: `${motor.name}: 0.0¬∞ (E:0 / T:0)` }) }); }); }); // Updated title format
        }

        function updateChart(chart, newData, newTitleText = null) { if (!chart || !chart.data) { return; } chart.data.labels.push(''); chart.data.datasets[0].data.push(newData); if (chart.data.labels.length > MAX_CHART_POINTS) { chart.data.labels.shift(); chart.data.datasets[0].data.shift(); } if (newTitleText && chart.options.plugins.title) { chart.options.plugins.title.text = newTitleText; } chart.update('none'); }

        function createAxisTextSprite(text, colorParams) {
            const fontface = 'Arial'; const fontsize = 64;
            const canvas = document.createElement('canvas'); const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(text); const textWidth = metrics.width;
            canvas.width = textWidth; canvas.height = fontsize * 1.2;
            context.font = `Bold ${fontsize}px ${fontface}`;
            context.fillStyle = `rgba(${colorParams.r}, ${colorParams.g}, ${colorParams.b}, ${colorParams.a})`;
            context.textAlign = 'center'; context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.Texture(canvas); texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            const spriteHeightInWorldUnits = 0.25;
            sprite.scale.set(spriteHeightInWorldUnits * (canvas.width / canvas.height), spriteHeightInWorldUnits, 1.0);
            return sprite;
        }

        function createDMPVisualizer(containerElement, espId) { // Renamed from createIMUVisualizer
            if (!containerElement || dmpVisualizers[espId]) return;
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            const camera = new THREE.PerspectiveCamera(50, containerElement.clientWidth / containerElement.clientHeight, 0.1, 100);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(containerElement.clientWidth, containerElement.clientHeight);
            containerElement.innerHTML = '';
            containerElement.appendChild(renderer.domElement);
            const geometry = new THREE.BoxGeometry(1.2, 0.4, 1.6); // X, Y, Z dimensions of the box
            const material = new THREE.MeshNormalMaterial({transparent:true, opacity:0.95});
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            const axesHelper = new THREE.AxesHelper(1.5);
            scene.add(axesHelper);

            const labelDist = 1.5 * 1.1; const labelOffset = 0.15;
            const xLabel = createAxisTextSprite('X', { r:255, g:0, b:0, a:1.0 });
            xLabel.position.set(labelDist, labelOffset, 0); scene.add(xLabel);
            const yLabel = createAxisTextSprite('Y', { r:0, g:255, b:0, a:1.0 });
            yLabel.position.set(labelOffset, labelDist, 0); scene.add(yLabel);
            const zLabel = createAxisTextSprite('Z', { r:0, g:0, b:255, a:1.0 });
            zLabel.position.set(0, labelOffset, labelDist); scene.add(zLabel);

            camera.position.set(2.44, 1.63, 4.35); camera.lookAt(0,0,0);
            dmpVisualizers[espId] = { cube, renderer, scene, camera, xLabel, yLabel, zLabel }; // Changed from imuVisualizers

            camera.aspect = containerElement.clientWidth / containerElement.clientHeight;
            camera.updateProjectionMatrix();

            function animate() {
                if (!dmpVisualizers[espId]) return; // Changed from imuVisualizers
                requestAnimationFrame(animate);
                dmpVisualizers[espId].renderer.render(dmpVisualizers[espId].scene, dmpVisualizers[espId].camera); // Changed from imuVisualizers
            }
            animate();
        }

        // MODIFIED updateDMPCube to use quaternion directly
        function updateDMPCube(espId, dmpDataFromPython) {
            const visualizer = dmpVisualizers[espId];
            if (!visualizer || !visualizer.cube || !dmpDataFromPython || !dmpDataFromPython.ypr_deg) {
                return;
            }

            const ypr = dmpDataFromPython.ypr_deg;

            let mpuYawDeg = parseFloat(ypr.yaw);
            let mpuPitchDeg = parseFloat(ypr.pitch);
            let mpuRollDeg = parseFloat(ypr.roll);

            if (isNaN(mpuYawDeg)) mpuYawDeg = 0;
            if (isNaN(mpuPitchDeg)) mpuPitchDeg = 0;
            if (isNaN(mpuRollDeg)) mpuRollDeg = 0;

            const mpuYawRad = THREE.MathUtils.degToRad(mpuYawDeg);
            const mpuPitchRad = THREE.MathUtils.degToRad(mpuPitchDeg);
            const mpuRollRad = THREE.MathUtils.degToRad(mpuRollDeg);

            visualizer.cube.rotation.order = 'YXZ'; 

            visualizer.cube.rotation.y = -mpuYawRad;
            visualizer.cube.rotation.x = -mpuPitchRad; // Inverted MPU Pitch for visual X-axis
            visualizer.cube.rotation.z = mpuRollRad;
        }

        function updateDashboardUI(data) {
            data.esps.forEach((esp, espIndex) => {
                const espIdString = `esp${espIndex}`;
                const espCardEl = document.getElementById(`${espIdString}-column`);
                const espIpEl = document.getElementById(`${espIdString}-ip`);
                const espDataStatusEl = document.getElementById(`${espIdString}-data-status`);
                const dmpSectionEl = document.getElementById(`${espIdString}-dmp-section`); // Renamed
                const dmpTextEl = document.getElementById(`${espIdString}-dmp-text`);       // Renamed
                const espDataAgeValueEl = document.getElementById(`${espIdString}-data-age-value`);

                if (!espCardEl) { console.warn(`ESP card for ${espIdString} not found.`); return;  }

                espCardEl.style.display = 'flex';
                if (espIpEl) espIpEl.textContent = esp.ip;
                if (espDataStatusEl) espDataStatusEl.style.backgroundColor = esp.data_available ? 'var(--success-color)' : 'var(--error-color)';

                if (esp.data_available) {
                    if (espDataAgeCharts[espIdString]) {
                        const ageTitle = `Data Age: ${esp.data_age_ms > 0 ? esp.data_age_ms.toFixed(0) : '-'} ms`;
                        updateChart(espDataAgeCharts[espIdString], esp.data_age_ms > 0 ? esp.data_age_ms : null, ageTitle);
                    }
                    if (espDataAgeValueEl) espDataAgeValueEl.textContent = `(${esp.data_age_ms > 0 ? esp.data_age_ms.toFixed(0) : '-'} ms)`;
                } else {
                     if (espDataAgeValueEl) espDataAgeValueEl.textContent = `(N/A)`;
                }

                // --- DMP Data Display ---
                if (esp.data_available && esp.dmp_ready) { // Check dmp_ready
                    if(dmpSectionEl) dmpSectionEl.style.display = 'flex';
                    const dmpCubeContainer = document.getElementById(`dmpCubeContainer-${espIdString}`); // Renamed
                    if (dmpCubeContainer && !dmpVisualizers[espIdString]) { // Changed from imuVisualizers
                        createDMPVisualizer(dmpCubeContainer, espIdString); // Renamed
                    }
                    if (dmpVisualizers[espIdString] && esp.dmp_data) { // Changed from imuVisualizers
                        updateDMPCube(espIdString, esp.dmp_data); // Pass the whole dmp_data object
                    }

                    if(dmpTextEl && esp.dmp_data) { // Check esp.dmp_data exists
                        let textContent = `<p><strong>DMP Status:</strong> READY</p>`;
                        const quat = esp.dmp_data.quaternion || {};
                        const accel = esp.dmp_data.world_accel_mps2 || {};
                        const ypr = esp.dmp_data.ypr_deg || {};

                        textContent += `<p><strong>Quat:</strong> W:${(quat.w||0).toFixed(2)}, X:${(quat.x||0).toFixed(2)}, Y:${(quat.y||0).toFixed(2)}, Z:${(quat.z||0).toFixed(2)}</p>`;
                        textContent += `<p><strong>World Accel (m/s¬≤):</strong> AX:${(accel.ax||0).toFixed(2)}, AY:${(accel.ay||0).toFixed(2)}, AZ:${(accel.az||0).toFixed(2)}</p>`;
                        textContent += `<p><strong>YPR (deg):</strong> Yaw:${(ypr.yaw||0).toFixed(1)}, Pitch:${(ypr.pitch||0).toFixed(1)}, Roll:${(ypr.roll||0).toFixed(1)}</p>`;
                        dmpTextEl.innerHTML = textContent;
                    }
                } else {
                    if(dmpSectionEl) dmpSectionEl.style.display = 'none';
                    if(dmpTextEl) dmpTextEl.innerHTML = `<p><strong>DMP Status:</strong> ${esp.data_available ? 'NOT READY' : 'NO DATA'}</p>`;
                }
                // --- End DMP Data Display ---


                esp.motors.forEach(motor => {
                    if (motorAngleCharts[motor.id]) {
                        // Display Angle, Encoder Position, and Target Position in chart title
                        const encPos = motor.encoderPos !== undefined ? motor.encoderPos : 'N/A';
                        const tgtPos = motor.targetPos !== undefined ? motor.targetPos : 'N/A';
                        const angle = motor.angle !== undefined ? motor.angle.toFixed(1) : 'N/A';
                        const newTitle = `${motor.name}: ${angle}¬∞ (E:${encPos} / T:${tgtPos})`;
                        updateChart(motorAngleCharts[motor.id], motor.angle, newTitle);
                        currentMotorTargetAngles[motor.id] = motor.angle;
                    }
                });
            });
        }

        updateToggleButtonText();
    </script>
</body>
</html>